<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Gravity Box</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">


  		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
  		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

		<style>

			body {
				background-color: #ccc;
				color: #000;
				font-family: sans-serif;
				user-select: none;
			}

			canvas:focus {
				outline: none;
			}


			#canvas {
				position: absolute;
				z-index: 0;
			}




	        /* Define the styles for the sidebar menu */
	        .menu {
	            position: fixed;
	            padding: 10px 20px;
	            top: 0;
	            left: -250px; /* Initially hide the menu off-screen */
	            width: 250px;
	            height: 100%;
	            background-color: #333;
	            color: #fff;
	            transition: left 0.1s;
	            overflow-y: auto;
	            z-index: 1;
	        }

	        .menu.active {
	            left: 0; /* Show the menu when active */
	        }




	        /* Style for the menu toggle button */
	        #showMenuButton {
	            position: fixed;
	            top: 1px;
	            left: 10px;
	            z-index: 2; /* Ensure it's above the canvas */
	        }

	        #buttons {
	        	position: fixed;
	        	z-index: 3;
	        	top: 0;
	        	right: 0;
	        	padding: 0px;
	        	margin: 0px;
	        	font-size: 3em;

	        }

	        #buttons > button {
	        	color: #4d4d4d;
	        	background-color: transparent;
	        	border: none;
	        }

	        #buttons > button:hover {
	        	color: #bfbfbf;
	        }


	        #playIcon {
	        	display: none;
	        }

	        #hideMenuButton {
	        	background-color: transparent;
	        	border: none;
	        	margin: 0px;
	        	padding: 0px;
	        	font-size: 1.4em;
	        	width: 30px;
	        	height: 30px;
	        	position: absolute;
	        	top: 5px;
	        	right: 5px;
	        	border-radius: 7px;
	        	display: flex;
	        	align-items: center;
	        	justify-content: center;
	        }

	        #hideMenuButton:hover {
	        	background-color: #bfbfbf;
	        }







		</style>




	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

	</head>



	<body>


	<div id="buttons" style="display: flex; flex-direction: row;">

		<button id="paintingButton">
			<i class="fa-solid fa-palette"></i>
		</button>

		<button id="playPauseButton">
		    <i id="playIcon" class="fa-solid fa-play"></i>
		    <i id="pauseIcon" class="fa-solid fa-pause"></i>
		</button>



	</div>

    <!-- Sidebar menu -->
    <div class="menu" id="menu">
        
        <button id="hideMenuButton"><i class="fa-solid fa-xmark"></i></button>

        <h2>Parameters</h2>

        <label for="brushWidth" class="form-label" style="margin-top: 10px;">Brush Width</label> (<span id="brushWidthValue">0.5</span>)
		<input type="range" class="form-range" min="0.2" max="5" step="0.001" value="0.5" id="brushWidth">

        <label for="brushDensity" class="form-label" style="margin-top: 20px;">Brush Density</label> (<span id="brushDensityValue">0.01</span>)
		<input type="range" class="form-range" min="0.005" max="0.2" step="0.00001" value="0.01" id="brushDensity">
        
        <label for="eccentricity" class="form-label" style="margin-top: 20px;">Orbital Eccentricity</label> (<span id="eccentricityValue">1.0</span>)
		<input type="range" class="form-range" min="0.25" max="1.5" step="0.001" value="1" id="eccentricity">  

        <label for="gravitationalConstant" class="form-label" style="margin-top: 20px;">Gravitational Const.</label> (<span id="gravitationalConstantValue">1.0</span>)
		<input type="range" class="form-range" min="0" max="10" step="0.001" value="1" id="gravitationalConstant">  

	    <div class="form-check form-switch" >
			<label class="form-check-label" for="clockwiseToggle" style="margin-top: 20px;">Reverse Injection Direction</label>
			<input type="checkbox" class="form-check-input" id="clockwiseToggle">
	    </div>

	    <div class="form-check form-switch" >
			<label class="form-check-label" for="toggleGrid" style="margin-top: 20px;">Toggle Grid</label>
			<input type="checkbox" class="form-check-input" id="toggleGrid" checked>
	    </div>

		<button type="button" class="btn btn-danger" id="clearParticles" style="margin-top: 20px;">Clear Particles</button>
		<button type="button" class="btn btn-secondary" id="reverseVelocities" style="margin-top: 10px;">Reverse Velocities</button>
		<button type="button" class="btn btn-secondary" id="zeroOutVelocities" style="margin-top: 10px;">Zero Out Velocities</button>

    </div>

    <!-- Menu toggle button -->
	<button type="button" class="btn btn-secondary" id="showMenuButton" style="margin-top: 10px;">Options</button>


	<canvas id="canvas"></canvas>

	<script type="module">


// Import modules
import * as THREE from 'https://unpkg.com/three@0.120.1/build/three.module.js';
import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/controls/OrbitControls.js';
//import {DragControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/controls/DragControls.js';
import {EffectComposer} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/postprocessing/EffectComposer.js';
import {RenderPass} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/postprocessing/RenderPass.js';
import {UnrealBloomPass} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/postprocessing/UnrealBloomPass.js';
import {ShaderPass} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/postprocessing/ShaderPass.js';


/*
INSTANTIATE SCRIPT VARIABLES
*/

// System parameters

// List of colors that stores a gradient on which to color particles as a function of velocity
const colors = [0x00FF00, 0x01FF00, 0x02FF00, 0x03FF00, 0x04FF00, 0x05FF00, 0x06FF00, 0x07FF00, 0x08FF00, 0x09FF00, 0x0AFF00, 0x0BFF00, 0x0CFF00, 0x0DFF00, 0x0EFF00, 0x0FFF00, 0x10FF00, 0x11FF00, 0x12FF00, 0x13FF00, 0x14FF00, 0x15FF00, 0x16FF00, 0x17FF00, 0x18FF00, 0x19FF00, 0x1AFF00, 0x1BFF00, 0x1CFF00, 0x1DFF00, 0x1EFF00, 0x1FFF00, 0x20FF00, 0x21FF00, 0x22FF00, 0x23FF00, 0x24FF00, 0x25FF00, 0x26FF00, 0x27FF00, 0x28FF00, 0x29FF00, 0x2AFF00, 0x2BFF00, 0x2CFF00, 0x2DFF00, 0x2EFF00, 0x2FFF00, 0x30FF00, 0x31FF00, 0x32FF00, 0x33FF00, 0x34FF00, 0x35FF00, 0x36FF00, 0x37FF00, 0x38FF00, 0x39FF00, 0x3AFF00, 0x3BFF00, 0x3CFF00, 0x3DFF00, 0x3EFF00, 0x3FFF00, 0x40FF00, 0x41FF00, 0x42FF00, 0x43FF00, 0x44FF00, 0x45FF00, 0x46FF00, 0x47FF00, 0x48FF00, 0x49FF00, 0x4AFF00, 0x4BFF00, 0x4CFF00, 0x4DFF00, 0x4EFF00, 0x4FFF00, 0x50FF00, 0x51FF00, 0x52FF00, 0x53FF00, 0x54FF00, 0x55FF00, 0x56FF00, 0x57FF00, 0x58FF00, 0x59FF00, 0x5AFF00, 0x5BFF00, 0x5CFF00, 0x5DFF00, 0x5EFF00, 0x5FFF00, 0x60FF00, 0x61FF00, 0x62FF00, 0x63FF00, 0x64FF00, 0x65FF00, 0x66FF00, 0x67FF00, 0x68FF00, 0x69FF00, 0x6AFF00, 0x6BFF00, 0x6CFF00, 0x6DFF00, 0x6EFF00, 0x6FFF00, 0x70FF00, 0x71FF00, 0x72FF00, 0x73FF00, 0x74FF00, 0x75FF00, 0x76FF00, 0x77FF00, 0x78FF00, 0x79FF00, 0x7AFF00, 0x7BFF00, 0x7CFF00, 0x7DFF00, 0x7EFF00, 0x7FFF00, 0x80FF00, 0x81FF00, 0x82FF00, 0x83FF00, 0x84FF00, 0x85FF00, 0x86FF00, 0x87FF00, 0x88FF00, 0x89FF00, 0x8AFF00, 0x8BFF00, 0x8CFF00, 0x8DFF00, 0x8EFF00, 0x8FFF00, 0x90FF00, 0x91FF00, 0x92FF00, 0x93FF00, 0x94FF00, 0x95FF00, 0x96FF00, 0x97FF00, 0x98FF00, 0x99FF00, 0x9AFF00, 0x9BFF00, 0x9CFF00, 0x9DFF00, 0x9EFF00, 0x9FFF00, 0xA0FF00, 0xA1FF00, 0xA2FF00, 0xA3FF00, 0xA4FF00, 0xA5FF00, 0xA6FF00, 0xA7FF00, 0xA8FF00, 0xA9FF00, 0xAAFF00, 0xABFF00, 0xACFF00, 0xADFF00, 0xAEFF00, 0xAFFF00, 0xB0FF00, 0xB1FF00, 0xB2FF00, 0xB3FF00, 0xB4FF00, 0xB5FF00, 0xB6FF00, 0xB7FF00, 0xB8FF00, 0xB9FF00, 0xBAFF00, 0xBBFF00, 0xBCFF00, 0xBDFF00, 0xBEFF00, 0xBFFF00, 0xC0FF00, 0xC1FF00, 0xC2FF00, 0xC3FF00, 0xC4FF00, 0xC5FF00, 0xC6FF00, 0xC7FF00, 0xC8FF00, 0xC9FF00, 0xCAFF00, 0xCBFF00, 0xCCFF00, 0xCDFF00, 0xCEFF00, 0xCFFF00, 0xD0FF00, 0xD1FF00, 0xD2FF00, 0xD3FF00, 0xD4FF00, 0xD5FF00, 0xD6FF00, 0xD7FF00, 0xD8FF00, 0xD9FF00, 0xDAFF00, 0xDBFF00, 0xDCFF00, 0xDDFF00, 0xDEFF00, 0xDFFF00, 0xE0FF00, 0xE1FF00, 0xE2FF00, 0xE3FF00, 0xE4FF00, 0xE5FF00, 0xE6FF00, 0xE7FF00, 0xE8FF00, 0xE9FF00, 0xEAFF00, 0xEBFF00, 0xECFF00, 0xEDFF00, 0xEEFF00, 0xEFFF00, 0xF0FF00, 0xF1FF00, 0xF2FF00, 0xF3FF00, 0xF4FF00, 0xF5FF00, 0xF6FF00, 0xF7FF00, 0xF8FF00, 0xF9FF00, 0xFAFF00, 0xFBFF00, 0xFCFF00, 0xFDFF00, 0xFEFF00, 0xFFFF00, 0xFFFE00, 0xFFFD00, 0xFFFC00, 0xFFFB00, 0xFFFA00, 0xFFF900, 0xFFF800, 0xFFF700, 0xFFF600, 0xFFF500, 0xFFF400, 0xFFF300, 0xFFF200, 0xFFF100, 0xFFF000, 0xFFEF00, 0xFFEE00, 0xFFED00, 0xFFEC00, 0xFFEB00, 0xFFEA00, 0xFFE900, 0xFFE800, 0xFFE700, 0xFFE600, 0xFFE500, 0xFFE400, 0xFFE300, 0xFFE200, 0xFFE100, 0xFFE000, 0xFFDF00, 0xFFDE00, 0xFFDD00, 0xFFDC00, 0xFFDB00, 0xFFDA00, 0xFFD900, 0xFFD800, 0xFFD700, 0xFFD600, 0xFFD500, 0xFFD400, 0xFFD300, 0xFFD200, 0xFFD100, 0xFFD000, 0xFFCF00, 0xFFCE00, 0xFFCD00, 0xFFCC00, 0xFFCB00, 0xFFCA00, 0xFFC900, 0xFFC800, 0xFFC700, 0xFFC600, 0xFFC500, 0xFFC400, 0xFFC300, 0xFFC200, 0xFFC100, 0xFFC000, 0xFFBF00, 0xFFBE00, 0xFFBD00, 0xFFBC00, 0xFFBB00, 0xFFBA00, 0xFFB900, 0xFFB800, 0xFFB700, 0xFFB600, 0xFFB500, 0xFFB400, 0xFFB300, 0xFFB200, 0xFFB100, 0xFFB000, 0xFFAF00, 0xFFAE00, 0xFFAD00, 0xFFAC00, 0xFFAB00, 0xFFAA00, 0xFFA900, 0xFFA800, 0xFFA700, 0xFFA600, 0xFFA500, 0xFFA400, 0xFFA300, 0xFFA200, 0xFFA100, 0xFFA000, 0xFF9F00, 0xFF9E00, 0xFF9D00, 0xFF9C00, 0xFF9B00, 0xFF9A00, 0xFF9900, 0xFF9800, 0xFF9700, 0xFF9600, 0xFF9500, 0xFF9400, 0xFF9300, 0xFF9200, 0xFF9100, 0xFF9000, 0xFF8F00, 0xFF8E00, 0xFF8D00, 0xFF8C00, 0xFF8B00, 0xFF8A00, 0xFF8900, 0xFF8800, 0xFF8700, 0xFF8600, 0xFF8500, 0xFF8400, 0xFF8300, 0xFF8200, 0xFF8100, 0xFF8000, 0xFF7F00, 0xFF7E00, 0xFF7D00, 0xFF7C00, 0xFF7B00, 0xFF7A00, 0xFF7900, 0xFF7800, 0xFF7700, 0xFF7600, 0xFF7500, 0xFF7400, 0xFF7300, 0xFF7200, 0xFF7100, 0xFF7000, 0xFF6F00, 0xFF6E00, 0xFF6D00, 0xFF6C00, 0xFF6B00, 0xFF6A00, 0xFF6900, 0xFF6800, 0xFF6700, 0xFF6600, 0xFF6500, 0xFF6400, 0xFF6300, 0xFF6200, 0xFF6100, 0xFF6000, 0xFF5F00, 0xFF5E00, 0xFF5D00, 0xFF5C00, 0xFF5B00, 0xFF5A00, 0xFF5900, 0xFF5800, 0xFF5700, 0xFF5600, 0xFF5500, 0xFF5400, 0xFF5300, 0xFF5200, 0xFF5100, 0xFF5000, 0xFF4F00, 0xFF4E00, 0xFF4D00, 0xFF4C00, 0xFF4B00, 0xFF4A00, 0xFF4900, 0xFF4800, 0xFF4700, 0xFF4600, 0xFF4500, 0xFF4400, 0xFF4300, 0xFF4200, 0xFF4100, 0xFF4000, 0xFF3F00, 0xFF3E00, 0xFF3D00, 0xFF3C00, 0xFF3B00, 0xFF3A00, 0xFF3900, 0xFF3800, 0xFF3700, 0xFF3600, 0xFF3500, 0xFF3400, 0xFF3300, 0xFF3200, 0xFF3100, 0xFF3000, 0xFF2F00, 0xFF2E00, 0xFF2D00, 0xFF2C00, 0xFF2B00, 0xFF2A00, 0xFF2900, 0xFF2800, 0xFF2700, 0xFF2600, 0xFF2500, 0xFF2400, 0xFF2300, 0xFF2200, 0xFF2100, 0xFF2000, 0xFF1F00, 0xFF1E00, 0xFF1D00, 0xFF1C00, 0xFF1B00, 0xFF1A00, 0xFF1900, 0xFF1800, 0xFF1700, 0xFF1600, 0xFF1500, 0xFF1400, 0xFF1300, 0xFF1200, 0xFF1100, 0xFF1000, 0xFF0F00, 0xFF0E00, 0xFF0D00, 0xFF0C00, 0xFF0B00, 0xFF0A00, 0xFF0900, 0xFF0800, 0xFF0700, 0xFF0600, 0xFF0500, 0xFF0400, 0xFF0300, 0xFF0200, 0xFF0100, 0xFF0000];

// List of colors that stores a gradient on which to color star particles as a function of velocity
let starColors = [0xFDB813, 0xfdb91c, 0xfcb103, 0xfdc135, 0xe3a002];

let camera, orbitControls, scene, renderer;

let r, d;

let l, w, h, x, y, z;

// Stores gravitational force
let force;

// Components of velocity and acceleration vectors used throughout
let v_x, v_y, v_z;
let a_x, a_y, a_z;

// Components of unit vector pointing either normal to the y-plane (directly upwards) or normal to the dynamicPlane
let u_x = 0;
let u_y = 1;
let u_z = 0;


// Components of stellar Center of Mass (COM)
let starCOM_x = 0;
let starCOM_y = 0;
let starCOM_z = 0;

// Sum of stellar mass
let starMassSum = 0;



// Define raycaster
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2(); // Store normalized mouse coordinates
let planeIntersection = new THREE.Vector3();
let planeObject;


// INPUT VARIABLES
let mouseDown = false;
let spaceBarDown = false;
let intersectingStar = false;
let intersectingButton = false; // stores if we are hovered over a button or not


// Higher order states
let play = false;
let painting = false;
let dragging = false;

let intersects;
let cameraQuaternion;


// Controls if orbital injection is CCW or CW
let clockwiseInjection = false

let r_x, r_y, r_z;
let phi, theta;
let starPosition;
let massWeightedStarPosition;




// particle index tracker for instanced mesh
let j = 0;

// Gravitational constant (fine-tuned for the environment)
let G = 1;

let numParticles = 50000;

// Controls spray brush width
let brushWidth = 0.5;

// Controls brush density
let brushDensity = 0.01;

// Controls ellipse curvature
let eccentricity = 1;

let cameraTarget = new THREE.Vector3(20, 20, 20);
let orbitTarget = new THREE.Vector3(0, 0, 0);

// Camera lerping variables
let lerpTime = 0;
let lerpRate = 0.01;
let panCamera = false;
let cameraDistance_x = 0;
let cameraDistance_y = 0;
let cameraDistance_z = 0;

let vs = [];
let vMean = 0;
let colorIndex = 0;


// Global matrix for assigning particle positions during each timestep
let matrix = new THREE.Matrix4();

// Global color for assigning particle colors during each timestep
const color = new THREE.Color();


// Instantiate the scene and set parameters
scene = new THREE.Scene();
scene.background = new THREE.Color( "black" );

let tag = document.getElementById("showMenuButton");

let canvas = document.getElementById("canvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;


// Instantiate renderer and set parameters
renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

// Instantiate camera and set parameters
camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
camera.position.set( 20, 20, 20 );

// Instantiate orbit orbitControls and set parameters
orbitControls = new OrbitControls( camera, renderer.domElement );
orbitControls.minDistance = 0;
orbitControls.maxDistance = 150;
orbitControls.maxPolarAngle = (2/3) * (Math.PI) + 0.4;

// Add grid to scene
let grid = new THREE.GridHelper(100, 30);
grid.name = "grid";
scene.add(grid);


// experimental

const renderScene = new RenderPass(scene, camera);
const composer = new EffectComposer(renderer);
composer.addPass(renderScene);

const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 2, 0.4, 0.1 );

//composer.addPass(bloomPass);


















let origin = new THREE.Vector3(0, 0, 0)


let starParams, stars, clouds, particles, starParticles, objs, mesh, instancedCount;



/*
PARAMETERS TO CONTROL STAR DRAGGING

(Operating principle: nothing subject to physical laws can be dragged)
*/






// Instantiate the scene
loadSystem();










// Create plane geometry and material
const planeGeometry = new THREE.PlaneGeometry(200, 200); // You can adjust the size as needed
const planeMaterial = new THREE.MeshBasicMaterial({
	color: 0x00ff00, 
	transparent: true, 
	opacity: 0,
	side: THREE.DoubleSide
});

// Create plane objects
const yPlaneObject = new THREE.Mesh(planeGeometry, planeMaterial);
const dynamicPlaneObject = new THREE.Mesh(planeGeometry, planeMaterial);

// Rotate if necessary
yPlaneObject.rotateX(Math.PI / 2); // Rotate the plane 90 degrees around the x-axis to make it a Y-plane

// Set position at origin
yPlaneObject.position.set(0, 0, 0);
dynamicPlaneObject.position.set(0, 0, 0);

// Add planes to scene
scene.add(yPlaneObject);
scene.add(dynamicPlaneObject);






function loadSystem() {

	starParams = [{
			type: "star",
			position: [0, 0, 0],
			velocity: [0, 0, 0],
			fixed: true,
			radius: 1.5,
			mass: 1,
		}];

	let k = 0;
	for (const starParam of starParams) {
		starParam.particles = 5000 * starParam.radius * starParam.radius * starParam.radius;

		// need to normalize and fix all of this, we actually use explicit x y and z, vectors are only for GUI!
		starParam.x = starParam.position[0];
		starParam.y = starParam.position[1];
		starParam.z = starParam.position[2];

		starParam.v_x = starParam.velocity[0];
		starParam.v_y = starParam.velocity[1];
		starParam.v_z = starParam.velocity[2];

		k += 1;

	}


	// Generate a particle system
	particles = [];

	for (let i = 0; i < numParticles; i++) {

		particles.push({
			index: i,
			active: false,

			x: 0,
			y: 0,
			z: 0,

			// Initial velocity
			v_x: 0,
			v_y: 0,
			v_z: 0,

			// Speed
			v: 0,
		})

	}


	// Count how many instances to feed into our particle mesh
	instancedCount = numParticles;

	// Create a box instance to act as the base object for the instanced Mesh
	const particleGeometry = new THREE.BoxGeometry(0.085, 0.085, 0.085);
	const particleMaterial = new THREE.MeshBasicMaterial();


	// Create an instanced mesh to represent all the particles
	mesh = new THREE.InstancedMesh(particleGeometry, particleMaterial, instancedCount);
	mesh.name = "mesh";
	scene.add(mesh);

	
	// Place each particle in the scene
	for (const particle of particles) {

		// Change the position of the matrix object to the position of the current particle
		matrix.setPosition(particle.x, particle.y, particle.z);

		// Change the matrix of the nth mesh object to the defined matrix object
		mesh.setMatrixAt(particle.index, matrix)
		mesh.setColorAt(particle.index, color.setHex( colors[255] ));

	}

	// Needed to update InstancedMesh object
	mesh.instanceMatrix.needsUpdate = true;
	mesh.instanceColor.needsUpdate = true;
	






	// [starObject, starParticles, starInstancedMesh]
	stars = [];

	for (const starParam of starParams) {

		// Generate an array of particle objects
		let starParticles = new generate_particles(starParams[0]);
		
		// Generate an InstancedMesh to hold these particles
		let starMesh = new THREE.InstancedMesh(particleGeometry, particleMaterial, starParticles.length);

		stars.push({params: starParam, particles: starParticles, mesh: starMesh})

	}


	// Add stars to scene
	for (const star of stars) {

		for (const particle of star.particles) {

			// Change the position of the matrix object to the position of the current particle
			matrix.setPosition(particle.x, particle.y, particle.z);
			
			// Change the matrix of the nth mesh object to the defined matrix object
			star.mesh.setMatrixAt(particle.index, matrix)
			star.mesh.setColorAt(particle.index, color.setHex( starColors[Math.floor(Math.random() * starColors.length)] ));
			star.mesh.position.set(star.params.x, star.params.y, star.params.z);

		}

		scene.add(star.mesh);


		// Needed to update InstancedMesh object
		star.mesh.instanceMatrix.needsUpdate = true;
		star.mesh.instanceColor.needsUpdate = true;

	}




	// Once everything is loaded, set physics in motion
	play = true;



}


// Start the animation
animate();


// Function to create InstancedMesh of particles
function generate_particles(params) {

	// Particle index tracker for instanced mesh
	j = 0;

	let particles = [];

	l = params.radius * 2;
	w = params.radius * 2;
	h = params.radius * 2;

	// For each i in the particle count
	for (let i = 0; i < params.particles; i++) {

		// Randomly generate (x, y, z) particle coordinates 
		// within the rectangular prism of dimensions (l, w, h)
		// centered at (x, y, z) = 0
		x = (Math.random() - 0.5) * l;
		y = (Math.random() - 0.5) * w;
		z = (Math.random() - 0.5) * h;

		// Compute the distance between the center of the star and the particle
		d = Math.sqrt((x * x) + (y * y) + (z * z));

		// Keep recomputing (x, y, z) particle coordinates (and corresponding distance to origin) until they are within desired radius
		while (d > params.radius) {

			x = (Math.random() - 0.5) * l;
			y = (Math.random() - 0.5) * w;
			z = (Math.random() - 0.5) * h;

			d = Math.sqrt((x * x) + (y * y) + (z * z));

		}

		// Initial velocity of particle is initial velocity of the cloud, by construction
		v_x = params.velocity[0];
		v_y = params.velocity[1];
		v_z = params.velocity[2];

		// Randomly initialize velocity if star particle
		if (params.type === "star") {
			v_x = (Math.random() - 0.5) * 0.05;
			v_y = (Math.random() - 0.5) * 0.05;
			v_z = (Math.random() - 0.5) * 0.05;
		}

		if (((params.type == "star") && (d > (params.radius * 0.8))) || (params.type != "star")) {

			particles.push({
				index: j,
				active: true,

				// Initial position, for star particles executing SHM
				x0: x,
				y0: y,
				z0: z,

				// Local position, for star particles executing SHM
				xLocal: x,
				yLocal: y,
				zLocal: z,

				// Randomly distributed spring constants in each direction
				kx: (Math.random() * (0.01 - 0.001) + 0.001) * params.radius,
				ky: (Math.random() * (0.01 - 0.001) + 0.001) * params.radius,
				kz: (Math.random() * (0.01 - 0.001) + 0.001) * params.radius,

				x: x + params.position[0],
				y: y + params.position[1],
				z: z + params.position[2],

				// Initial velocity
				v_x: v_x,
				v_y: v_y,
				v_z: v_z,

				// Speed
				v: 0,

			});

			j += 1;

		}

	}				

	return particles;
}




function moveOutsideTime() {

	for (const star of stars) {

		if (dragging) {
			star.mesh.position.x = planeIntersection.x;
			star.mesh.position.y = planeIntersection.y;
			star.mesh.position.z = planeIntersection.z;
		}

	}


}



// Update the physics of each particle
function move() {

	starCOM_x = 0;
	starCOM_y = 0;
	starCOM_z = 0;
	starMassSum = 0;

	// Execute SHM for star particles
	for (const star of stars) {

		starPosition = star.mesh.position.clone()

		starCOM_x += star.mesh.position.x * star.params.mass
		starCOM_y += star.mesh.position.y * star.params.mass
		starCOM_z += star.mesh.position.z * star.params.mass
		starMassSum += star.params.mass;

		for (const particle of star.particles) {

			a_x = -particle.kx * (particle.xLocal - particle.x0);
			a_y = -particle.ky * (particle.yLocal - particle.y0);
			a_z = -particle.kz * (particle.zLocal - particle.z0);

			particle.v_x += a_x;
			particle.v_y += a_y;
			particle.v_z += a_z;

			particle.xLocal += particle.v_x;
			particle.yLocal += particle.v_y;
			particle.zLocal += particle.v_z;

			matrix.setPosition(particle.xLocal, particle.yLocal, particle.zLocal);
			star.mesh.setMatrixAt(particle.index, matrix);

		}

		// Needed to update InstancedMesh object
		star.mesh.instanceMatrix.needsUpdate = true;
		star.mesh.instanceColor.needsUpdate = true;

	}

	// Get COM vector for all stars combined
	starCOM_x /= starMassSum;
	starCOM_y /= starMassSum;
	starCOM_z /= starMassSum;

	// List to keep track of velocities for each particle
	vs = [];

	// Iterate through every particle
	for (const particle of particles) {

		// All particles are recyclable
		if (painting && Math.random() < brushDensity) {

			// Orbital injection logic

           	// Vector pointing from stellar COM to injection point
           	// WHY CANT THIS BE NORMALIZED?????
           	r_x = planeIntersection.x - starCOM_x;
           	r_y = planeIntersection.y - starCOM_y;
           	r_z = planeIntersection.z - starCOM_z;

			// Distance between stellar COM and injection point
           	let rMag = Math.sqrt((r_x * r_x) + (r_y * r_y) + (r_z * r_z));

           	// Normalized vector to store initial velocity direction
           	// v0Hat is cross product of u and r
           	let v0Hat_x = (u_y * r_z) - (u_z * r_y);
           	let v0Hat_y = (u_z * r_x) - (u_x * r_z);
           	let v0Hat_z = (u_x * r_y) - (u_y * r_x);

			// Normalize v0Hat
			let v0HatMag = Math.sqrt((v0Hat_x * v0Hat_x) + (v0Hat_y * v0Hat_y) + (v0Hat_z * v0Hat_z));
			v0Hat_x /= v0HatMag;
			v0Hat_y /= v0HatMag;
			v0Hat_z /= v0HatMag;

           	if (clockwiseInjection) {
           		v0Hat_x *= -1;
           		v0Hat_y *= -1;
           		v0Hat_z *= -1;
           	}

            // Calculate the tangential velocity for circular orbit
            // Scale this velocity by user inputted eccentricity parameter
            let vTan = eccentricity * Math.sqrt(G / rMag);

            // Set the initial velocity with the magnitude of tangential velocity
            particle.v_x = v0Hat_x * vTan;
            particle.v_y = v0Hat_y * vTan;
            particle.v_z = v0Hat_z * vTan;

			// Generate random spherical coordinates (on surface of sphere)
			phi = Math.random() * Math.PI * 2; // azimuthal angle (0 to 2*Pi)
			theta = Math.acos(2 * Math.random() - 1); // polar angle (0 to Pi)

			// Convert spherical coordinates to Cartesian coordinates
			particle.x = planeIntersection.x + (brushWidth * Math.sin(theta) * Math.cos(phi));
			particle.y = planeIntersection.y + (brushWidth * Math.sin(theta) * Math.sin(phi));
			particle.z = planeIntersection.z + (brushWidth * Math.cos(theta));

            // Mark the particle as active
            particle.active = true;

            // Update the particle's position in the instanced mesh
            mesh.setMatrixAt(particle.index, new THREE.Matrix4().makeTranslation(particle.x, particle.y, particle.z));

		}

		let R = Math.sqrt((particle.x * particle.x) + (particle.y * particle.y) + (particle.z * particle.z));

		// Outside system boundary
		if (R > 100) {
			particle.active = false;
			matrix.setPosition(0, 0, 0);
			mesh.setMatrixAt(particle.index, matrix);
			continue;
		}

		// Reset accelerations
		a_x = 0;
		a_y = 0;
		a_z = 0;

		for (const star of stars) {

			r_x = star.mesh.position.x - particle.x;
			r_y = star.mesh.position.y - particle.y;
			r_z = star.mesh.position.z - particle.z;
		
			r = Math.sqrt((r_x * r_x) + (r_y * r_y) + (r_z * r_z));

			// Sucked into star
			if (r < star.params.radius) {
				particle.active = false;
				matrix.setPosition(0, 0, 0);
				mesh.setMatrixAt(particle.index, matrix);
				break;
			}

			force = (G * star.params.mass) / (r * r);

			a_x += (force * r_x) / r;
			a_y += (force * r_y) / r;
			a_z += (force * r_z) / r;


		}

		particle.v_x += a_x;
		particle.v_y += a_y;
		particle.v_z += a_z;

		particle.x += particle.v_x;
		particle.y += particle.v_y;
		particle.z += particle.v_z;

		particle.v = Math.sqrt((particle.v_x * particle.v_x) + (particle.v_y * particle.v_y) + (particle.v_z * particle.v_z));

		vs.push(particle.v);
		
	}


	vMean = 0;

	for (const v of vs) {
		vMean += v;
	}

	vMean /= vs.length;


	// Iterate through every particle
	for (const particle of particles) {

		if (particle.active == false) {
			continue
		}

		// Update particle position and color
		matrix.setPosition(particle.x, particle.y, particle.z);

		// Use sigmoid function to compute new color based on particle velocity and average velocity of the system
		colorIndex = Math.floor(511 / (1 + Math.exp(-10 * (particle.v - vMean))));
		
		mesh.setMatrixAt(particle.index, matrix);
		mesh.setColorAt(particle.index, color.setHex( colors[colorIndex] ));

	}

	// Needed to update InstancedMesh object
	mesh.instanceMatrix.needsUpdate = true;
	mesh.instanceColor.needsUpdate = true;
	

}



function updateDynamicPlane() {

	// Update dynamicPlaneObject to always be centered at the stellar COM
	dynamicPlaneObject.position.x = starCOM_x;
	dynamicPlaneObject.position.y = starCOM_y;
	dynamicPlaneObject.position.z = starCOM_z;

	yPlaneObject.position.x = starCOM_x;
	yPlaneObject.position.y = starCOM_y;
	yPlaneObject.position.z = starCOM_z;

	// THIS CODE SHOULD BE A LOT MORE EFFICIENT AND SENSIBLE

	
	// Update dynamicPlaneObject to always be perpendicular to vector emanating from camera
	cameraQuaternion = new THREE.Quaternion();
	camera.getWorldQuaternion(cameraQuaternion);
	dynamicPlaneObject.setRotationFromQuaternion(cameraQuaternion);
	dynamicPlaneObject.updateMatrixWorld();


}

//orbitControls.enabled = false;

// Function that seeks to track mouse location in 3D space
function trackInput(event) {
    
    let clientX, clientY, touches;

    if (event.type === "mousemove") {
        clientX = event.clientX;
        clientY = event.clientY;
    } else if (event.type === "touchmove" || event.type == "touchstart") {
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
    }

    // Calculate input position in normalized device coordinates (NDC)
    mouse.x = (clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(clientY / window.innerHeight) * 2 + 1;

    // Update the raycaster's origin and direction based on the input position
    raycaster.setFromCamera(mouse, camera);

    // Logic for moving star
    intersects = raycaster.intersectObject(stars[0].mesh);

    if (intersects.length > 0) {
    	intersectingStar = true;
    }

    // Get the camera's direction vector
    const cameraDirection = new THREE.Vector3();
    camera.getWorldDirection(cameraDirection);

    // Create a vector pointing along the Y-axis
    const yAxis = new THREE.Vector3(0, 1, 0);

    // Calculate the angle between the camera direction and Y-axis
    const angle = cameraDirection.angleTo(yAxis);

    // Convert the angle from radians to degrees
    const angleDegrees = THREE.MathUtils.radToDeg(angle);

    if (angleDegrees < 120) {
        planeObject = dynamicPlaneObject;

		// Get the normalized direction vector of dynamicPlaneObject
		const directionVector = new THREE.Vector3();
		dynamicPlaneObject.getWorldDirection(directionVector);

        // Assign unit vector to orthonormal vector of dynamic plane
		u_x = directionVector.x;
		u_y = directionVector.y;
		u_z = directionVector.z;


    } else {
        planeObject = yPlaneObject;

        // Assign unit vector to orthonormal vector of y-plane
        u_x = 0;
        u_y = 1;
        u_z = 0;

    }


    // Find intersection against y-plane
    intersects = raycaster.intersectObject(planeObject);

    if (intersects.length > 0) {
        planeIntersection = intersects[0].point;
    }

    event.preventDefault();

}























function animate() {

	//tag.innerHTML = mouseDown + ", " + spaceBarDown + ", " + intersectingButton + ", " + orbitControls.enabled;

	// Navigation logic
	if (spaceBarDown || intersectingStar) {
		
		orbitControls.enabled = false;

		if (!mouseDown) {
			intersectingStar = false;
		}

		// Painting mode
		if (mouseDown && spaceBarDown && !intersectingButton) {
			dragging = false;
			painting = true;

		// Dragging mode
		} else if (mouseDown && intersectingStar && !intersectingButton) {
			dragging = true;
			painting = false;
		}

	} else {
		orbitControls.enabled = true;
		dragging = false;
		painting = false;

		// Required here; this is true until broken by another event
		intersectingStar = false;
	}

	updateDynamicPlane();

	//panCamera = true;
	// Request new frame
	requestAnimationFrame(animate);

	if (panCamera) {

		console.log(lerpTime);

		lerpTime += lerpRate;

		if (lerpTime >= 1) {
			lerpTime = 0;
			panCamera = false;
		}

	    // Update the camera's target position using linear interpolation
	    orbitControls.target.lerp(new THREE.Vector3(starCOM_x, starCOM_y, starCOM_z), lerpTime);

	    // NEED TO FIX THE BELOW:

	    camera.position.lerp(new THREE.Vector3(starCOM_x + cameraDistance_x, starCOM_y + cameraDistance_x, starCOM_z + cameraDistance_x), lerpTime);

	    // Calculate the camera's current position
	    const currentCameraPosition = camera.position.clone();

	    // Calculate the camera's new look-at position using linear interpolation
	    const newLookAtPosition = new THREE.Vector3(starCOM_x, starCOM_y, starCOM_z).lerp(currentCameraPosition, lerpTime);

	    // Update the camera's lookAt
	    camera.lookAt(newLookAtPosition);
	}

	// renderer.render( scene, camera );
	composer.render();

	// Non-time dependent physics
	moveOutsideTime();

	// Skip the move() function if paused
	if (!play) {
		return;
	}

	// Update physics
	move();

}


/*
----------------------------------------------------
BELOW THIS POINT IS JAVASCRIPT THAT CONTROLS THE GUI
----------------------------------------------------
*/

// Attach mousemove and click event listeners to the window
canvas.addEventListener("mousemove", trackInput, { passive: false });
canvas.addEventListener("click", trackInput, { passive: false });
canvas.addEventListener("touchstart", trackInput, { passive: false });
canvas.addEventListener("touchmove", trackInput, { passive: false });
canvas.addEventListener("mousedown", (event) => { mouseDown = true; event.preventDefault(); }, { passive: false });
canvas.addEventListener("touchstart", (event) => { mouseDown = true; event.preventDefault(); }, { passive: false });
canvas.addEventListener("touchmove", (event) => { mouseDown = true; event.preventDefault(); }, { passive: false });
canvas.addEventListener("touchend", (event) => { mouseDown = false; });
canvas.addEventListener("mouseup", (event) => { mouseDown = false; event.preventDefault(); }, { passive: false });

// JavaScript to toggle the menu
let menu = document.getElementById("menu");
let showMenuButton = document.getElementById("showMenuButton");
let buttons = document.getElementById("buttons");

buttons.addEventListener("mouseenter", () => { intersectingButton = true; });
buttons.addEventListener("touchstart", () => { intersectingButton = true; });
buttons.addEventListener("mouseleave", () => { intersectingButton = false; });
buttons.addEventListener("touchend", () => { intersectingButton = false; });
menu.addEventListener("mouseenter", () => { intersectingButton = true; });
menu.addEventListener("touchstart", () => { intersectingButton = true; });
menu.addEventListener("mouseleave", () => { intersectingButton = false; });
menu.addEventListener("touchend", () => { intersectingButton = false; });
showMenuButton.addEventListener("mouseenter", () => { intersectingButton = true; });
showMenuButton.addEventListener("touchstart", () => { intersectingButton = true; });
showMenuButton.addEventListener("mouseleave", () => { intersectingButton = false; });
showMenuButton.addEventListener("touchend", () => { intersectingButton = false; });
showMenuButton.addEventListener("click", () => { 
	menu.classList.toggle("active");
	showMenuButton.style.display = "none"; 
});

hideMenuButton.addEventListener("click", () => { 
	menu.classList.toggle("active");
	showMenuButton.style.display = "block"; 
});

// Add event listeners
window.addEventListener("pointerdown", () => { panCamera = false; });
window.addEventListener("resize", () => {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
});

window.addEventListener("keydown", () => {
	if (event.keyCode == 71) {
		play = !play;
	} else if (event.key == "c") {
		lerpTime = 0;
		panCamera = true;

		cameraDistance_x = camera.position.x - starCOM_x;
		cameraDistance_y = camera.position.y - starCOM_y;
		cameraDistance_z = camera.position.z - starCOM_z;

	}
});

window.addEventListener("keydown", (event) => {
	if (event.key == " ") {
		spaceBarDown = true;
	}
});

window.addEventListener("keyup", (event) => {
	if (event.key == " ") {
		spaceBarDown = false;
	}
});	


// JavaScript to get slider objects
let brushWidthSlider = document.getElementById("brushWidth");
let brushDensitySlider = document.getElementById("brushDensity");
let eccentricitySlider = document.getElementById("eccentricity");
let gravitationalConstantSlider = document.getElementById("gravitationalConstant");

let clearParticlesButton = document.getElementById("clearParticles");
let reverseVelocitiesButton = document.getElementById("reverseVelocities");
let zeroOutVelocitiesButton = document.getElementById("zeroOutVelocities");

let brushWidthValue = document.getElementById("brushWidthValue");
let brushDensityValue = document.getElementById("brushDensityValue");
let eccentricityValue = document.getElementById("eccentricityValue");
let gravitationalConstantValue = document.getElementById("gravitationalConstantValue");

brushWidthSlider.addEventListener("input", () => {
    let value = parseFloat(brushWidthSlider.value);
    brushWidth = value;
    brushWidthValue.innerHTML = value.toFixed(2);
});

brushDensitySlider.addEventListener("input", () => {
    let value = parseFloat(brushDensitySlider.value);
    brushDensity = value;
    brushDensityValue.innerHTML = value.toFixed(2);
});

eccentricitySlider.addEventListener("input", () => {
    let value = parseFloat(eccentricitySlider.value);
    eccentricity = value;
    eccentricityValue.innerHTML = value.toFixed(2);
});

gravitationalConstantSlider.addEventListener("input", () => {
    let value = parseFloat(gravitationalConstantSlider.value);
    G = value;
    gravitationalConstantValue.innerHTML = value.toFixed(2);
});

clearParticlesButton.addEventListener("click", () => {
	for (const particle of particles) {
		particle.active = false;
		matrix.setPosition(0, 0, 0);
		mesh.setMatrixAt(particle.index, matrix);
	}

	// Needed to update InstancedMesh object
	mesh.instanceMatrix.needsUpdate = true;
	mesh.instanceColor.needsUpdate = true;
});

reverseVelocitiesButton.addEventListener("click", () => {
	for (const particle of particles) {
		particle.v_x *= -1;
		particle.v_y *= -1;
		particle.v_z *= -1;

	}
});

zeroOutVelocitiesButton.addEventListener("click", () => {
	for (const particle of particles) {
		particle.v_x = 0;
		particle.v_y = 0;
		particle.v_z = 0;
	}
});

// Play/Pause button
let playPauseButton = document.getElementById("playPauseButton");
let playIcon = document.getElementById("playIcon");
let pauseIcon = document.getElementById("pauseIcon");

playPauseButton.addEventListener("click", () => {
    if (play) {
        play = false; // Pause the simulation
        playIcon.style.display = "block";
        pauseIcon.style.display = "none";
    } else {
        play = true; // Resume the simulation
        playIcon.style.display = "none";
        pauseIcon.style.display = "block";
    }
});


// Grab painting toggle button
let paintingButton = document.getElementById("paintingButton");

paintingButton.addEventListener("click", () => {

	spaceBarDown = !spaceBarDown;

	if (spaceBarDown) {
		paintingButton.style.color = "";
	} else {
		paintingButton.style.color = "blue";
	}

});


let clockwiseToggle = document.getElementById("clockwiseToggle");

clockwiseToggle.addEventListener("change", () => {
	if (clockwiseToggle.checked) {
		clockwiseInjection = true;
	} else {
		clockwiseInjection = false;
	}
});


let toggleGrid = document.getElementById("toggleGrid");

toggleGrid.addEventListener("change", () => {
	let gridObject = scene.getObjectByName("grid");
	let gridVisibility = gridObject.visible;
	
	if (toggleGrid.checked) {
		gridObject.visible = true;
	} else {
		gridObject.visible = false;
	}

});


</script>
</body>
</html>